#!/bin/bash

set -ueo pipefail

# whats my name?
APP=${0##*/}

# Uncomment to enable command logging to file
#LOG="/tmp/$APP.history"

QUIET=0

_color() {
	RED=$'\e[0;31m'
	GREEN=$'\e[0;32m'
	YELLOW=$'\e[0;33m'
	RESET=$'\e[0m'
	DELETE=$'\r\e[K' # delete current line
}

_nocolor() {
	RED=
	GREEN=
	YELLOW=
	RESET=
	DELETE=$'\n'
}

[ -t 1 ] && _color || _nocolor
for i; do
	case "$i" in
		--color)
			_color;   shift;;
		--nocolor)
			_nocolor; shift;;
		--quiet)
			# no output from command on success
			QUIET=1;  shift;;
		*)
			break;
	esac
done

_exe() {
	local i CMD CODE COUNT RESULT SPACE

	# multiple arguments? try to escape if necessary
	if [ $# -gt 1 ]; then
		# Legacy (multiple arguments; kept for compatibility)
		# todo
		echo -e "${RED}Warning: legacy!!$RESET\n" >&2
		for i in "$@"; do
				# escape bash operators & build-ins
				if [[ "$i" =~ ^[0-9\<\>\|\&\*\;]+$|^time$ ]]; then
					CMD+=" $i"
				else
					# since we use ' ourself, we need to escape it
					#i=$(echo "$i" | sed 's/'\''/'\''\\'\'\''/g') # use printf, to avoid problems with echo options in $i, e.g. -n
					# shellcheck disable=SC1003
					i=$(printf "%s\n" "$i" | sed 's/'\''/'\''\\'\'\''/g')
					CMD+=' '\'"$i"\'
				fi
		done
		CMD=${CMD:1}
	else
		CMD=$1
	fi

	# logging
	if [ -n "${LOG:-}" ]; then
		printf "%s\t%s\n" "$(date '+%F %T')" "$CMD" >> "$LOG"
	fi

	# in progress
	printf "%s" "[ $YELLOW..$RESET ] $YELLOW>>$RESET $CMD"

	if RESULT=$(bash -c -- "$CMD" 2>&1); then
		# success; is there output?
		[ -n "$RESULT" ] && {
			# more than one line output?
			if [[ "$RESULT" == *$'\n'* ]]; then
				COUNT=$(( ${#CMD} + 14 ))
				SPACE=$(printf "%${COUNT}s")
				# shellcheck disable=SC2001
				RESULT=$(sed "s/^/$SPACE/g" <<<"$RESULT")
				RESULT=${RESULT:$COUNT}
			fi
			RESULT=" $YELLOW>>$RESET $GREEN$RESULT$RESET"
		}
		echo -n "$DELETE"
		if [ "$QUIET" -eq 1 ]; then
			printf "%s\n" "[$GREEN OK $RESET] $YELLOW>>$RESET $CMD"
		else
			printf "%s\n" "[$GREEN OK $RESET] $YELLOW>>$RESET $CMD$RESULT"
		fi
		exit 0
	else
		# errocode > 0
		CODE=$?
		# is there output?
		[ -n "$RESULT" ] && {
			# more than one line output?
			if [[ "$RESULT" == *$'\n'* ]]; then
				COUNT=$(( ${#CMD} + 17 ))
				SPACE=$(printf "%${COUNT}s")
				RESULT=$(echo -n "$RESULT" | sed "s/^/$SPACE/g")
				RESULT=${RESULT:$COUNT}
			fi
			RESULT=" $YELLOW>>$RESET $RED$RESULT$RESET"
		}
		echo -n "$DELETE"
		printf "%s\n" "[$RED ERROR $RESET] $YELLOW>>$RESET $CMD$RESULT"
		exit "$CODE"
	fi
}

_usage() {
	local DEMO

	echo "Executes a command and show result/output in a nice way. Original return code is preserved."
	echo
	echo "Usage: $APP [options] <command>"
	echo
	echo "       --color     force color usage"
	echo "       --nocolor   force no color usage"
	echo "       --quiet     show no output from command on success"
	echo "       <command>   command to execute"
	echo

	# shellcheck disable=SC2140
	echo "Example: $YELLOW$APP "\""echo 'hello world'\"$RESET"
	DEMO=$("$APP" --color "echo 'hello world'")
	echo "Result:  ${DEMO##*$'\r'}"
	echo

	# shellcheck disable=SC2140
	echo "Example: $YELLOW$APP "\""echo 'hello world'; false\"$RESET"
	DEMO=$("$APP" --color "echo 'hello world'; false"; true)
	echo "Result:  ${DEMO##*$'\r'}"
	echo

	# shellcheck disable=SC2140
	echo "Example: $YELLOW$APP --quiet "\""echo 'hello world'\"$RESET"
	DEMO=$("$APP" --color --quiet "echo 'hello world'"; true)
	echo "Result:  ${DEMO##*$'\r'}"
	echo

	exit 1
} >&2

# no arguments? show usage
[ $# -lt 1 ] &&	_usage

_exe "$@"
