#!/bin/bash

set -ueo pipefail

# whats my name?
APP=${0##*/}

# Uncomment to enable command logging to file
#LOG="/tmp/$APP.history"

# force color?
[ "${1:-}" == "--color" ] && COLOR=1 && shift || COLOR=0

# no tty? no colors!
tty -s || [ "$COLOR" -eq 1 ] && RED=$(echo -ne "\e[0;31m")	|| RED=
tty -s || [ "$COLOR" -eq 1 ] && GREEN=$(echo -ne "\e[0;32m")	|| GREEN=
tty -s || [ "$COLOR" -eq 1 ] && YELLOW=$(echo -ne "\e[0;33m")	|| YELLOW=
tty -s || [ "$COLOR" -eq 1 ] && RESET=$(echo -ne "\e[0m")	|| RESET=	# reset fg/bg color
tty -s || [ "$COLOR" -eq 1 ] && DELETE=$(echo -ne "\r\033[K")	|| DELETE=$'\n'	# delete current line

_exe() {
	local i CMD CODE ERROR RESULT

	# multiple arguments? try to escape if necessary
	if [ $# -gt 1 ]; then
		# Legacy (kept for compatibility)
		for i in "$@"; do
				# escape bash operators & build-ins
				if [[ "$i" =~ ^[0-9\<\>\|\&\*\;]+$|^time$ ]]; then
					CMD+=" $i"
				else
					# since we use ' ourself, we need to escape it
					#i=$(echo "$i" | sed 's/'\''/'\''\\'\'\''/g') # use printf, to avoid problems with echo options in $i, e.g. -n
					# shellcheck disable=SC1003
					i=$(printf "%s\n" "$i" | sed 's/'\''/'\''\\'\'\''/g')
					CMD+=' '\'"$i"\'
				fi
		done
		CMD=${CMD:1}
	else
		CMD=$1
	fi

	# logging
	if [ -n "${LOG:-}" ]; then
		printf "%s\t%s\n" "$(date '+%F %T')" "$CMD" >> "$LOG"
	fi

	# in progress
	printf "%s" "[ $YELLOW..$RESET ] $YELLOW>>$RESET $CMD"

	if RESULT=$(bash -c "$CMD" 2>&1); then
		# success; is there output?
		[ -n "$RESULT" ] && {
			# more than one line output?
			if [[ "$RESULT" == *$'\n'* ]]; then
				COUNT=$(( ${#CMD} + 14 ))
				SPACE=$(printf "%${COUNT}s")
				RESULT=$(echo -n "$RESULT" | sed "s/^/$SPACE/g")
				RESULT=${RESULT:$COUNT}
			fi
			RESULT=" $YELLOW>>$RESET $GREEN$RESULT$RESET"
		}
		echo -n "$DELETE"
		printf "%s\n" "[$GREEN OK $RESET] $YELLOW>>$RESET $CMD$RESULT"
		exit 0
	else
		# errocode > 0
		CODE=$?
		# is there output?
		[ -n "$RESULT" ] && {
			# more than one line output?
			if [[ "$RESULT" == *$'\n'* ]]; then
				COUNT=$(( ${#CMD} + 17 ))
				SPACE=$(printf "%${COUNT}s")
				RESULT=$(echo -n "$RESULT" | sed "s/^/$SPACE/g")
				RESULT=${RESULT:$COUNT}
			fi
			RESULT=" $YELLOW>>$RESET $RED$RESULT$RESET"
		}
		echo -n "$DELETE"
		printf "%s\n" "[$RED ERROR $RESET] $YELLOW>>$RESET $CMD$RESULT"
		exit "$CODE"
	fi
}

_line() {
	echo
	printf '%.0s-' $(seq 1 ${COLUMNS:-80})
	echo
	echo
}

_usage() {
	local DEMO ERROR

	echo "Executes a command and show result/output in a nice way. Original return code is preserved."
	echo
	echo "Usage: $APP [--color] <command>"
	echo
	echo "       --color     force color usage"
	echo "       <command>   command to execute"
	echo
	_line

	# shellcheck disable=SC2140
	echo "Example: $YELLOW$APP "\""echo 'hello world'\"$RESET"
	echo
	DEMO=$("$APP" "echo 'hello world'")
	ERROR=$?
	echo "Result:"
	echo
	echo "$DEMO"
	echo "Return code: $GREEN$ERROR$RESET"
	_line

	# shellcheck disable=SC2140
	echo "Example with error: $YELLOW$APP "\""echo 'hello world'; false\"$RESET"
	echo
	set +e
	DEMO=$("$APP" "echo 'hello world'; false")
	ERROR=$?
	set -e
	echo "Result:"
	echo
	echo "$DEMO"
	echo "Return code: $RED$ERROR$RESET"
	_line

	echo "Example with pipe: $YELLOW$APP 'echo foo | cat'$RESET"
	echo
	DEMO=$("$APP" 'echo foo | cat')
	ERROR=$?
	echo "Result:"
	echo
	echo "$DEMO"
	echo "Return code: $GREEN$ERROR$RESET"
	_line

	echo "(Deprecated) Example with multible arguments and escaped pipe: $YELLOW$APP echo foo '|' cat$RESET"
	echo
	DEMO=$("$APP" echo foo '|' cat)
	ERROR=$?
	echo "Result:"
	echo
	echo "$DEMO"
	echo "Return code: $GREEN$ERROR$RESET"
	echo

	exit 1
} >&2

# no arguments? show usage
[ $# -lt 1 ] &&	_usage

_exe "$@"
